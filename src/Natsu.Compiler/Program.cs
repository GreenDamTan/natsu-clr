using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection.Metadata;
using System.Runtime.CompilerServices;
using System.Text;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Natsu.Compiler
{
    class Program
    {
        static void Main(string[] args)
        {
            var path = @"..\..\..\..\..\out\bin\netcoreapp3.0\Chino.Kernel.dll";
            var resolver = new AssemblyResolver();
            var modCtx = new ModuleContext(resolver);
            resolver.DefaultModuleContext = modCtx;
            resolver.EnableTypeDefCache = true;
            resolver.FindExactMatch = false;
            resolver.UseGAC = false;
            resolver.PreSearchPaths.Add(Path.GetFullPath(@"..\..\..\..\..\out\bin\netcoreapp3.0"));
            resolver.PreSearchPaths.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), @".nuget\packages\bitfields\0.1.0\lib\netstandard1.0"));

            var modules = new HashSet<ModuleDef>();

            void AddAssemblies(ModuleDef module)
            {
                modules.Add(module);

                foreach (var ass in module.GetAssemblyRefs())
                {
                    var r = resolver.ResolveThrow(ass, module);
                    foreach (var m in r.Modules)
                        AddAssemblies(m);
                }
            }

            AddAssemblies(ModuleDefMD.Load(path));

            foreach (var module in modules)
            {
                var generator = new Generator(module);
                generator.Generate();
            }
        }
    }

    class Generator
    {
        private readonly ModuleDef _module;
        private readonly Dictionary<TypeDef, TypeDesc> _typeDescs = new Dictionary<TypeDef, TypeDesc>();
        private readonly List<TypeDesc> _sortedTypeDescs = new List<TypeDesc>();
        private readonly CorLibTypes _corLibTypes;
        private TypeDesc _szArrayType;

        public Generator(ModuleDef module)
        {
            _module = module;
            _corLibTypes = new CorLibTypes(module);
        }

        public void Generate()
        {
            foreach (var type in _module.GetTypes())
            {
                var typeDesc = new TypeDesc(type);
                _typeDescs.Add(type, typeDesc);

                if (type.FullName == "System.SZArray`1")
                    _szArrayType = typeDesc;
            }

            SortTypes();

            var outputPath = Path.GetFullPath(@"..\..\..\..\Native\Generated");
            Directory.CreateDirectory(outputPath);

            using (var writer = new StreamWriter(Path.Combine(outputPath, $"{_module.Assembly.Name}.h")))
            {
                writer.WriteLine("// Generated by natsu clr compiler.");
                writer.WriteLine("#pragma once");
                if (_module.Assembly.Name == "System.Private.CorLib")
                {
                    writer.WriteLine("#include <natsu.runtime.h>");
                }
                else
                {
                    foreach (var ass in _module.GetAssemblyRefs())
                        writer.WriteLine($"#include <{ass.Name}.h>");
                }

                writer.WriteLine();

                writer.WriteLine($"namespace {EscapeModuleName(_module)}");
                writer.WriteLine("{");
                WriteTypeForwards(writer);
                writer.WriteLine();
                WriteTypeForwardDeclares(writer);
                writer.WriteLine();
                WriteTypeDeclares(writer);
                writer.WriteLine("}");
                writer.WriteLine();

                writer.WriteLine($"namespace {EscapeModuleName(_module)}");
                writer.WriteLine("{");
                WriteTypeMethodsBody(writer, true);
                writer.WriteLine("}");
            }

            using (var writer = new StreamWriter(Path.Combine(outputPath, $"{_module.Assembly.Name}.cpp")))
            {
                writer.WriteLine("// Generated by natsu clr compiler.");
                writer.WriteLine($"#include \"{_module.Assembly.Name}.h\"");
                writer.WriteLine();

                writer.WriteLine($"namespace {EscapeModuleName(_module)}");
                writer.WriteLine("{");
                WriteTypeMethodsBody(writer, false);
                WriteConstantStringFields(writer);
                writer.WriteLine("}");
            }
        }

        private void WriteConstantStringFields(StreamWriter writer)
        {
            foreach (var type in _sortedTypeDescs)
            {
                if (!type.TypeDef.IsEnum)
                {
                    foreach (var field in type.TypeDef.Fields)
                    {
                        if (field.HasConstant && field.ElementType == ElementType.String)
                            WriteConstantStringField(writer, 0, field);
                    }
                }
            }
        }

        private void SortTypes()
        {
            foreach (var type in _typeDescs.Values)
            {
                foreach (var field in type.TypeDef.Fields)
                    AddTypeRef(type, field.FieldType, false);

                var baseType = GetTypeDef(GetBaseType(type.TypeDef));
                if (baseType != null)
                    AddTypeRef(type, baseType, true);

                foreach (var iface in type.TypeDef.Interfaces)
                {
                    var typeDef = GetTypeDef(iface.Interface);
                    AddTypeRef(type, typeDef, true);
                }
            }

            var visited = new HashSet<TypeDesc>();
            void VisitType(TypeDesc type)
            {
                if (visited.Add(type))
                {
                    foreach (var parent in type.UsedTypes)
                        VisitType(parent);
                    _sortedTypeDescs.Add(type);
                }
            }

            foreach (var type in _typeDescs.Values)
                VisitType(type);
        }

        private TypeDef GetTypeDef(ITypeDefOrRef type)
        {
            var typeDef = type as TypeDef;
            if (typeDef == null)
            {
                if (type is TypeSpec typeSpec)
                {
                    var cntSig = typeSpec.TypeSig;
                    while (true)
                    {
                        switch (cntSig.ElementType)
                        {
                            case ElementType.Class:
                                {
                                    var sig = cntSig.ToClassSig();
                                    return sig.TypeDef;
                                }
                            case ElementType.GenericInst:
                                {
                                    var sig = cntSig.ToGenericInstSig();
                                    cntSig = sig.GenericType;
                                    break;
                                }
                            default:
                                cntSig = cntSig.Next;
                                break;
                        }

                        if (typeDef != null)
                            return typeDef;

                        if (cntSig == null)
                            return null;
                    }
                }
            }

            return typeDef;
        }

        private ITypeDefOrRef GetBaseType(TypeDef type)
        {
            return type.BaseType;
        }

        private void AddTypeRef(TypeDesc declareDesc, TypeSig fieldType, bool force)
        {
            var cntSig = fieldType;
            while (cntSig != null)
            {
                switch (cntSig.ElementType)
                {
                    case ElementType.Void:
                    case ElementType.Var:
                    case ElementType.ByRef:
                    case ElementType.Ptr:
                    case ElementType.CModReqd:
                    case ElementType.GenericInst:
                    case ElementType.Object:
                    case ElementType.Class:
                        break;
                    case ElementType.Boolean:
                    case ElementType.Char:
                    case ElementType.I1:
                    case ElementType.U1:
                    case ElementType.I2:
                    case ElementType.U2:
                    case ElementType.I4:
                    case ElementType.U4:
                    case ElementType.I8:
                    case ElementType.U8:
                    case ElementType.R4:
                    case ElementType.R8:
                    case ElementType.String:
                    case ElementType.I:
                    case ElementType.U:
                        {
                            if (cntSig.TryGetTypeDef() != declareDesc.TypeDef)
                                AddTypeRef(declareDesc, cntSig.TryGetTypeDef(), force);
                        }
                        break;
                    case ElementType.ValueType:
                        AddTypeRef(declareDesc, cntSig.TryGetTypeDef(), force);
                        break;
                    case ElementType.SZArray:
                        AddTypeRef(declareDesc, _szArrayType.TypeDef, force);
                        break;
                    default:
                        throw new NotSupportedException();
                }

                cntSig = cntSig.Next;
            }
        }

        private void AddTypeRef(TypeDesc declareDesc, TypeDef typeDef, bool force)
        {
            if (typeDef != null && (force || typeDef.IsValueType))
            {
                if (_typeDescs.TryGetValue(typeDef, out var targetDesc))
                {
                    if (declareDesc != targetDesc)
                    {
                        declareDesc.UsedTypes.Add(targetDesc);
                        targetDesc.UsedByTypes.Add(declareDesc);
                    }
                }
            }
        }

        private void WriteTypeForwards(StreamWriter writer)
        {
            var types = _module.ExportedTypes.Where(x => x.Attributes == TypeAttributes.Forwarder).ToList();
            var index = 0;
            foreach (var type in types)
            {
                WriteTypeForward(writer, 0, type);
                if (index++ != types.Count - 1)
                    writer.WriteLine();
            }

            if (types.Any())
                writer.WriteLine();
        }

        private void WriteTypeForward(StreamWriter writer, int ident, dnlib.DotNet.ExportedType type)
        {
            var nss = type.Namespace.Split('.', StringSplitOptions.RemoveEmptyEntries)
                .Select(EscapeNamespaceName).ToList();

            writer.Ident(ident);
            foreach (var ns in nss)
                writer.Write($"namespace {ns} {{ ");

            var fowardName = "::" + EscapeModuleName(type.Implementation.Name) + "::" + EscapeTypeName(type.ToTypeRef(), true, false);
            if (type.Name.Contains("`"))
            {
                var types = int.Parse(type.Name.Substring(type.Name.IndexOf('`') + 1));
                var genDecl = $"<{string.Join(", ", Enumerable.Range(0, types).Select(x => "class T" + x))}>";
                var genImpl = $"<{string.Join(", ", Enumerable.Range(0, types).Select(x => "T" + x))}>";
                writer.Ident(ident).Write($"template {genDecl} ");
                writer.Ident(ident).Write($"using {EscapeTypeName(type.Name)} = {fowardName}{genImpl};");
            }
            else
            {
                writer.Ident(ident).Write($"using {EscapeTypeName(type.Name)} = {fowardName}; ");
            }

            foreach (var ns in nss)
                writer.Write(" }");
        }

        #region Forward Declares
        private void WriteTypeForwardDeclares(StreamWriter writer)
        {
            var types = _typeDescs.Values.ToList();
            var index = 0;
            foreach (var type in types)
            {
                WriteTypeForwardDeclare(writer, 0, type);
                if (index++ != types.Count - 1)
                    writer.WriteLine();
            }
        }

        private void WriteTypeForwardDeclare(StreamWriter writer, int ident, TypeDesc type)
        {
            var nss = type.TypeDef.Namespace.String.Split('.', StringSplitOptions.RemoveEmptyEntries)
                .Select(EscapeNamespaceName).ToList();

            writer.Ident(ident);
            foreach (var ns in nss)
                writer.Write($"namespace {ns} {{ ");

            if (type.TypeDef.HasGenericParameters)
            {
                var typeNames = type.TypeDef.GenericParameters.Select(x => "class " + x.Name.String).ToList();
                writer.Ident(ident).Write($"template <{string.Join(", ", typeNames)}> ");
            }

            writer.Ident(ident).Write($"struct {type.Name};");

            foreach (var ns in nss)
                writer.Write(" }");
        }
        #endregion

        #region Declares

        private void WriteTypeDeclares(StreamWriter writer)
        {
            var index = 0;
            foreach (var type in _sortedTypeDescs)
            {
                WriteTypeDeclare(writer, 0, type);
                if (index++ != _sortedTypeDescs.Count - 1)
                    writer.WriteLine();
            }
        }

        private void WriteTypeDeclare(StreamWriter writer, int ident, TypeDesc type)
        {
            bool hasStaticMember = false;

            var nss = type.TypeDef.Namespace.String.Split('.', StringSplitOptions.RemoveEmptyEntries)
                .Select(EscapeNamespaceName).ToList();

            writer.Ident(ident);
            foreach (var ns in nss)
                writer.Write($"namespace {ns} {{ ");

            writer.WriteLine();
            if (type.TypeDef.HasGenericParameters)
            {
                var typeNames = type.TypeDef.GenericParameters.Select(x => "class " + x.Name.String).ToList();
                writer.Ident(ident).WriteLine($"template <{string.Join(", ", typeNames)}> ");
            }

            writer.Ident(ident).Write($"struct {type.Name}");
            if (!type.TypeDef.IsValueType)
            {
                var baseType = GetBaseType(type.TypeDef);
                if (baseType != null)
                    writer.WriteLine(" : public " + EscapeTypeName(baseType, true, true));
                else
                    writer.WriteLine(" : public ::natsu::object");
            }
            else
            {
                writer.WriteLine();
            }

            writer.Ident(ident).WriteLine("{");

            // VTable
            WriteVTableDeclare(writer, ident + 1, type);
            writer.WriteLine();

            foreach (var field in type.TypeDef.Fields)
            {
                if (field.HasConstant && field.ElementType != ElementType.String)
                    WriteConstantField(writer, ident + 1, field);
                else if (!field.IsStatic || field.ElementType == ElementType.String)
                    WriteField(writer, ident + 1, field);
                else
                    hasStaticMember = true;
            }

            writer.WriteLine();

            foreach (var method in type.TypeDef.Methods)
            {
                if (method.IsStaticConstructor)
                {
                    hasStaticMember = true;
                }
                else if (!method.IsAbstract)
                {
                    WriteMethodDeclare(writer, ident + 1, method);
                }
            }

            if (type.TypeDef.IsPrimitive)
            {
                writer.WriteLine();
                writer.Ident(ident + 1).WriteLine($"NATSU_PRIMITIVE_IMPL_{type.TypeDef.Name.ToUpperInvariant()}");
            }

            if (type.TypeDef.IsEnum)
            {
                writer.WriteLine();
                writer.Ident(ident + 1).WriteLine($"NATSU_ENUM_IMPL_{type.TypeDef.GetEnumUnderlyingType().TypeName.ToUpperInvariant()}({type.TypeDef.Name})");
            }

            if (type.TypeDef.ToTypeSig().ElementType == ElementType.Object)
            {
                writer.WriteLine();
                writer.Ident(ident + 1).WriteLine($"NATSU_OBJECT_IMPL");
            }

            if (type.TypeDef == _szArrayType?.TypeDef)
            {
                writer.WriteLine();
                writer.Ident(ident + 1).WriteLine($"NATSU_SZARRAY_IMPL");
            }

            writer.Ident(ident).WriteLine("};");

            // Static
            if (hasStaticMember)
            {
                writer.WriteLine();
                writer.Ident(ident).WriteLine($"struct {type.Name}_Static");
                writer.Ident(ident).WriteLine("{");

                foreach (var field in type.TypeDef.Fields)
                {
                    if (field.IsStatic && !field.HasConstant)
                        WriteField(writer, ident + 1, field, true);
                }

                writer.WriteLine();

                foreach (var method in type.TypeDef.Methods)
                {
                    if (method.IsStaticConstructor)
                        WriteMethodDeclare(writer, ident + 1, method);
                }

                writer.Ident(ident).WriteLine("};");
            }

            foreach (var ns in nss)
                writer.Write("} ");
            writer.WriteLine();
        }

        private void WriteVTableDeclare(StreamWriter writer, int ident, TypeDesc type)
        {
            writer.Ident(ident).Write($"struct VTable : public ");
            var baseType = GetBaseType(type.TypeDef);
            if (baseType == null)
                writer.Write("virtual natsu::vtable_t");
            else
                writer.Write($"{EscapeTypeName(baseType, true, true)}::VTable");

            foreach (var iface in type.TypeDef.Interfaces)
            {
                var ifaceType = iface.Interface;
                writer.Write($", public virtual {EscapeTypeName(ifaceType, true, true)}::VTable");
            }

            writer.WriteLine();

            writer.Ident(ident).WriteLine("{");

            foreach (var method in type.TypeDef.Methods)
            {
                if (!method.IsInstanceConstructor && !method.IsStatic)
                    WriteVTableMethodDeclare(writer, ident + 1, method);
            }

            writer.Ident(ident).WriteLine("};");
        }

        private string EscapeTypeName(ITypeDefOrRef type, TypeDefOrRefSig sig, bool isBaseType, bool hasModuleName, bool isVTable)
        {
            return EscapeTypeNameImpl(type, sig.IsValueType, isBaseType, hasModuleName, isVTable, true);
        }

        private string EscapeTypeNameImpl(ITypeDefOrRef type, bool isValueType, bool isBaseType, bool hasModuleName, bool isVTable, bool hasGen)
        {
            if (type is TypeSpec typeSpec)
            {
                return EscapeTypeName(typeSpec.TypeSig, null, isBaseType, isVTable);
            }

            var sb = new StringBuilder();
            if (!isBaseType && !isValueType)
                sb.Append("::natsu::gc_obj_ref<");

            if (hasModuleName)
                sb.Append("::" + EscapeModuleName(type.DefinitionAssembly) + "::");
            var nss = type.Namespace.Split('.', StringSplitOptions.RemoveEmptyEntries)
                .Select(EscapeNamespaceName).ToList();
            foreach (var ns in nss)
                sb.Append($"{ns}::");
            sb.Append(EscapeTypeName(type.Name));
            if (isVTable)
                sb.Append("_VTable");
            if (hasGen && type is TypeDef typeDef && typeDef.HasGenericParameters && !type.ContainsGenericParameter)
            {
                sb.Append("<");
                sb.Append(string.Join(", ", typeDef.GenericParameters.Select(x => x.Name)));
                sb.Append(">");
            }

            if (!isBaseType && !isValueType)
                sb.Append(">");

            return sb.ToString();
        }

        private string EscapeTypeName(ITypeDefOrRef type, bool isBaseType, bool hasModuleName, bool isVTable = false)
        {
            return EscapeTypeNameImpl(type, type.IsValueType, isBaseType, hasModuleName, isVTable, false);
        }

        private static string EscapeTypeName(string name)
        {
            return name.Replace('<', '_').Replace('>', '_').Replace('`', '_');
        }

        private void WriteField(StreamWriter writer, int ident, FieldDef value, bool isStatic = false)
        {
            string prefix = string.Empty;
            if (value.IsStatic && !isStatic)
                prefix = "static ";

            writer.Ident(ident).WriteLine($"{prefix}{EscapeTypeName(value.FieldType, value.DeclaringType)} {EscapeIdentifier(value.Name)};");
        }

        private void WriteStaticField(StreamWriter writer, int ident, FieldDef value)
        {
            writer.Ident(ident).WriteLine($"{EscapeTypeName(value.FieldType, value.DeclaringType)} {EscapeTypeName(value.DeclaringType, true, false)}::{EscapeIdentifier(value.Name)};");
        }

        private void WriteConstantStringField(StreamWriter writer, int ident, FieldDef value)
        {
            writer.Ident(ident).WriteLine($"{EscapeTypeName(value.FieldType, value.DeclaringType)} {EscapeTypeName(value.DeclaringType, true, false)}::{EscapeIdentifier(value.Name)} = ::natsu::load_string(uR\"NS({value.Constant.Value})NS\");");
        }

        private void WriteMethodDeclare(StreamWriter writer, int ident, MethodDef method)
        {
            if (!method.IsStaticConstructor)
                writer.Ident(ident).Write("static " + EscapeTypeName(method.ReturnType) + " ");
            else
                writer.Ident(ident);
            writer.Write(EscapeMethodName(method) + "(");

            var index = 0;
            var parameters = method.Parameters.ToList();
            foreach (var param in parameters)
            {
                writer.Write(EscapeTypeName(param.Type));
                var paramName = param.IsHiddenThisParameter ? "_this" : param.Name;
                writer.Write(" " + EscapeIdentifier(paramName));
                if (index++ != parameters.Count - 1)
                    writer.Write(", ");
            }

            writer.WriteLine($");");
        }

        private string EscapeTypeName(TypeSig fieldType, TypeDef declaringType = null, bool isBaseType = false, bool isVTable = false)
        {
            var sb = new StringBuilder();
            EscapeTypeName(sb, fieldType, declaringType, isBaseType, isVTable);
            return sb.ToString();
        }

        private void EscapeTypeName(StringBuilder sb, TypeSig cntSig, TypeDef declaringType = null, bool isBaseType = false, bool isVTable = false)
        {
            switch (cntSig.ElementType)
            {
                case ElementType.Void:
                    sb.Append("void");
                    break;
                case ElementType.Boolean:
                case ElementType.Char:
                case ElementType.I1:
                case ElementType.U1:
                case ElementType.I2:
                case ElementType.U2:
                case ElementType.I4:
                case ElementType.U4:
                case ElementType.I8:
                case ElementType.U8:
                case ElementType.R4:
                case ElementType.R8:
                case ElementType.String:
                case ElementType.I:
                case ElementType.U:
                    {
                        switch (cntSig)
                        {
                            case TypeDefOrRefSig sig:
                                if (sig.TypeDef == declaringType)
                                    sb.Append(GetConstantTypeName(cntSig.ElementType));
                                else
                                    sb.Append(EscapeTypeName(sig.TypeDefOrRef, sig, isBaseType: isBaseType, hasModuleName: true, isVTable: isVTable));
                                break;
                            default:
                                throw new NotSupportedException();
                        }
                    }
                    break;
                case ElementType.ValueType:
                case ElementType.Class:
                case ElementType.Object:
                    {
                        switch (cntSig)
                        {
                            case TypeDefOrRefSig sig:
                                if (sig.IsValueType && declaringType != null && sig.TypeDef == declaringType)
                                    sb.Append(GetConstantTypeName(cntSig.ElementType));
                                else
                                    sb.Append(EscapeTypeName(sig.TypeDefOrRef, sig, isBaseType: isBaseType, hasModuleName: true, isVTable: isVTable));
                                break;
                            default:
                                throw new NotSupportedException();
                        }
                    }
                    break;
                case ElementType.SZArray:
                    sb.Append("::natsu::gc_obj_ref<::System_Private_CorLib::System::SZArray_1<");
                    EscapeTypeName(sb, cntSig.Next, declaringType);
                    sb.Append(">>");
                    break;
                case ElementType.Var:
                    sb.Append(cntSig.ToGenericVar().GetName());
                    break;
                case ElementType.GenericInst:
                    {
                        var sig = cntSig.ToGenericInstSig();
                        sb.Append(EscapeTypeName(sig.GenericType.TypeDefOrRef, isBaseType: isBaseType, hasModuleName: true, isVTable: isVTable));
                        sb.Append("<");
                        for (int i = 0; i < sig.GenericArguments.Count; i++)
                        {
                            EscapeTypeName(sb, sig.GenericArguments[i], null);
                            if (i != sig.GenericArguments.Count - 1)
                                sb.Append(", ");
                        }
                        sb.Append(">");
                    }
                    break;
                case ElementType.ByRef:
                    sb.Append("::natsu::gc_ref<");
                    EscapeTypeName(sb, cntSig.Next, declaringType);
                    sb.Append(">");
                    break;
                case ElementType.Ptr:
                    sb.Append("::natsu::gc_ptr<");
                    EscapeTypeName(sb, cntSig.Next, declaringType);
                    sb.Append(">");
                    break;
                case ElementType.Pinned:
                    EscapeTypeName(sb, cntSig.Next, declaringType);
                    break;
                case ElementType.CModReqd:
                    EscapeTypeName(sb, cntSig.Next, declaringType);
                    break;
                default:
                    throw new NotSupportedException();
            }
        }

        private void WriteConstantField(StreamWriter writer, int ident, FieldDef value)
        {
            string prefix = string.Empty;
            if (value.IsStatic)
                prefix = "static ";

            writer.Ident(ident).WriteLine($"{prefix}constexpr {GetConstantTypeName(value.ElementType)} {EscapeIdentifier(value.Name)} = {LiteralConstant(value.Constant.Value)};");
        }

        private string LiteralConstant(object value)
        {
            var text = value switch
            {
                char i => ((ushort)i).ToString(),
                byte i => i.ToString(),
                sbyte i => i.ToString(),
                ushort i => i.ToString(),
                short i => i.ToString(),
                uint i => i.ToString(),
                int i => i.ToString(),
                ulong i => i.ToString() + "ULL",
                long i => "::natsu::to_int64(0x" + Unsafe.As<long, ulong>(ref i).ToString("X") + ") /* " + i.ToString() + "*/",
                float i => "::natsu::to_float(0x" + Unsafe.As<float, uint>(ref i).ToString("X") + ") /* " + i.ToString() + "*/",
                double i => "::natsu::to_double(0x" + Unsafe.As<double, ulong>(ref i).ToString("X") + ") /* " + i.ToString() + "*/",

                _ => throw new NotSupportedException("Unsupported constant")
            };

            return text;
        }
        #endregion

        private void WriteTypeMethodsBody(StreamWriter writer, bool inHeader)
        {
            foreach (var type in _sortedTypeDescs)
            {
                WriteTypeMethodBody(writer, 0, type, inHeader);
            }
        }

        private void WriteTypeMethodBody(StreamWriter writer, int ident, TypeDesc type, bool inHeader)
        {
            foreach (var method in type.TypeDef.Methods)
            {
                if (inHeader == (type.TypeDef.HasGenericParameters || method.HasGenericParameters))
                {
                    if (!method.IsAbstract)
                    {
                        if (!method.IsInstanceConstructor && !method.IsStatic)
                        {
                            WriteVTableMethodBody(writer, ident, method);
                            writer.WriteLine();
                        }

                        if (!method.IsInternalCall)
                        {
                            WriteMethodBody(writer, ident, method);
                            writer.WriteLine();
                        }
                    }
                }
            }
        }

        private void WriteMethodBody(StreamWriter writer, int ident, MethodDef method)
        {
            writer.Ident(ident);
            var typeGens = new List<string>();
            var methodGens = new List<string>();

            if (method.DeclaringType.HasGenericParameters)
                typeGens.AddRange(method.DeclaringType.GenericParameters.Select(x => x.Name.String));
            if (method.HasGenericParameters)
                methodGens.AddRange(method.GenericParameters.Select(x => x.Name.String));

            if (typeGens.Any() || methodGens.Any())
                writer.WriteLine($"template <{string.Join(", ", typeGens.Concat(methodGens).Select(x => "class " + x))}>");

            if (!method.IsStaticConstructor)
                writer.Write(EscapeTypeName(method.ReturnType) + " ");
            writer.Write(EscapeTypeName(method.DeclaringType, isBaseType: true, hasModuleName: false));
            if (method.IsStaticConstructor)
                writer.Write("_Static");
            if (typeGens.Any())
                writer.Write($"<{string.Join(", ", typeGens)}>");
            writer.Write("::" + EscapeMethodName(method) + "(");

            var index = 0;
            var parameters = method.Parameters;
            foreach (var param in parameters)
            {
                writer.Write(EscapeTypeName(param.Type));
                var paramName = param.IsHiddenThisParameter ? "_this" : param.Name;
                writer.Write(" " + EscapeIdentifier(paramName));
                if (index++ != parameters.Count - 1)
                    writer.Write(", ");
            }

            writer.WriteLine(")");
            writer.Ident(ident).WriteLine("{");
            WriteILBody(writer, ident + 1, method);
            writer.Ident(ident).WriteLine("}");
            writer.Flush();
        }

        private void WriteVTableMethodDeclare(StreamWriter writer, int ident, MethodDef method)
        {
            writer.Ident(ident);

            if (method.HasGenericParameters)
                throw new NotSupportedException("Virtual generic methods is not supported");

            if (method.IsVirtual)
                writer.Write("virtual ");
            writer.Write(EscapeTypeName(method.ReturnType) + " ");
            writer.Write(EscapeMethodName(method) + "(");

            var index = 0;
            var parameters = method.Parameters;
            foreach (var param in parameters)
            {
                writer.Write(EscapeTypeName(param.Type));
                var paramName = param.IsHiddenThisParameter ? "_this" : param.Name;
                writer.Write(" " + EscapeIdentifier(paramName));
                if (index++ != parameters.Count - 1)
                    writer.Write(", ");
            }

            writer.Write(") const");
            if (method.IsAbstract)
            {
                writer.WriteLine(" = 0;");
            }
            else
            {
                writer.WriteLine(";");
            }

            writer.Flush();
        }

        private void WriteVTableMethodBody(StreamWriter writer, int ident, MethodDef method)
        {
            writer.Ident(ident);
            var typeGens = new List<string>();
            var methodGens = new List<string>();

            if (method.DeclaringType.HasGenericParameters)
                typeGens.AddRange(method.DeclaringType.GenericParameters.Select(x => x.Name.String));
            if (method.HasGenericParameters)
                throw new NotSupportedException("Virtual generic methods is not supported");

            if (typeGens.Any() || methodGens.Any())
                writer.WriteLine($"template <{string.Join(", ", typeGens.Concat(methodGens).Select(x => "class " + x))}>");

            writer.Write(EscapeTypeName(method.ReturnType) + " ");
            writer.Write(EscapeTypeName(method.DeclaringType, isBaseType: true, hasModuleName: false));
            if (typeGens.Any())
                writer.Write($"<{string.Join(", ", typeGens)}>");
            writer.Write("::VTable::" + EscapeMethodName(method) + "(");

            var index = 0;
            var parameters = method.Parameters;
            foreach (var param in parameters)
            {
                writer.Write(EscapeTypeName(param.Type));
                var paramName = param.IsHiddenThisParameter ? "_this" : param.Name;
                writer.Write(" " + EscapeIdentifier(paramName));
                if (index++ != parameters.Count - 1)
                    writer.Write(", ");
            }

            writer.WriteLine(") const");
            writer.Ident(ident).WriteLine("{");
            writer.Ident(ident + 1).WriteLine("assert(_this);");
            writer.Ident(ident + 1).Write("return ");
            writer.Write(EscapeTypeName(method.DeclaringType, true, true));
            if (typeGens.Any())
                writer.Write($"<{string.Join(", ", typeGens)}>");
            writer.Write("::" + EscapeMethodName(method) + "(");
            index = 0;
            foreach (var param in parameters)
            {
                var paramName = param.IsHiddenThisParameter ? "_this" : param.Name;
                writer.Write(EscapeIdentifier(paramName));
                if (index++ != parameters.Count - 1)
                    writer.Write(", ");
            }
            writer.WriteLine(");");
            writer.Ident(ident).WriteLine("}");

            writer.Flush();
        }

        private void WriteILBody(StreamWriter writer, int ident, MethodDef method)
        {
            var body = method.Body;
            var stack = new EvaluationStack(writer, ident);

            foreach (var local in body.Variables)
            {
                WriteLocal(local, stack, writer, ident, method);
            }

            Console.WriteLine(method);
            var head = ImportBlocks(body.Instructions);

            void VisitBlock(int ident, BasicBlock block, EvaluationStack evaluationStack)
            {
                writer.WriteLine(GetLabel(method, block.Id) + ":");

                foreach (var op in block.Instructions)
                {
                    WriteInstruction(op, evaluationStack, writer, ident, method, block);
                }

                foreach (var next in block.Next)
                {
                    writer.Ident(ident).WriteLine("{");
                    VisitBlock(ident + 1, next, evaluationStack.Clone(1));
                    writer.Ident(ident).WriteLine("}");
                }
            }

            VisitBlock(ident, head, stack);
        }

        private BasicBlock ImportBlocks(IList<Instruction> instructions)
        {
            int id = 0;
            Instruction NextInst(Instruction inst)
            {
                var index = instructions.IndexOf(inst);
                if (index < instructions.Count - 1)
                    return instructions[index + 1];
                return null;
            }

            BasicBlock ImportBlock(Instruction inst)
            {
                if (inst == null) return null;

                var block = new BasicBlock { Id = id++ };
                bool conti = true;

                void AddNext(Instruction next)
                {
                    if (block.Instructions[0] != next)
                        block.Next.Add(ImportBlock(next));
                }

                while (conti)
                {
                    switch (inst.OpCode.Code)
                    {
                        case Code.Br_S:
                            block.Instructions.Add(inst);
                            AddNext((Instruction)inst.Operand);
                            conti = false;
                            break;
                        case Code.Brfalse:
                        case Code.Brfalse_S:
                        case Code.Brtrue_S:
                        case Code.Bne_Un_S:
                        case Code.Bge_Un_S:
                        case Code.Blt_S:
                            block.Instructions.Add(inst);
                            AddNext((Instruction)inst.Operand);
                            AddNext(NextInst(inst));
                            conti = false;
                            break;
                        case Code.Ret:
                        case Code.Throw:
                            block.Instructions.Add(inst);
                            conti = false;
                            break;
                        default:
                            if (inst.OpCode.Code.ToString().StartsWith('B'))
                                throw new NotImplementedException();

                            block.Instructions.Add(inst);
                            inst = NextInst(inst);
                            break;
                    }
                }

                return block;
            }

            BasicBlock head;
            if (instructions.Count != 0)
                head = ImportBlock(instructions[0]);
            else
                head = new BasicBlock { Id = 0 };

            return head;
        }

        class BasicBlock
        {
            public int Id { get; set; }

            public List<Instruction> Instructions { get; } = new List<Instruction>();

            public List<BasicBlock> Next { get; set; } = new List<BasicBlock>();
        }

        private string GetLabel(MethodDef method, int id)
        {
            return $"M{method.Rid:X4}_{id}";
        }

        private string GetLabel(MethodDef method, Instruction instruction, BasicBlock block)
        {
            var id = instruction == block.Instructions[0]
                ? block.Id
                : block.Next.First(x => x.Instructions[0] == instruction).Id;
            return GetLabel(method, id);
        }

        private string GetFallthroughLabel(MethodDef method, Instruction instruction, BasicBlock block)
        {
            var nextInst = method.Body.Instructions[method.Body.Instructions.IndexOf(instruction) + 1];
            var id = block.Next.First(x => x.Instructions[0] == nextInst).Id;
            return GetLabel(method, id);
        }

        private void WriteLocal(Local local, EvaluationStack stack, StreamWriter writer, int ident, MethodDef method)
        {
            writer.Ident(ident).WriteLine($"{EscapeTypeName(local.Type)} _l{local.Index};");
        }

        private void WriteInstruction(Instruction op, EvaluationStack stack, StreamWriter writer, int ident, MethodDef method, BasicBlock block)
        {
            void ConvertLdarg_I(int index)
            {
                ConvertLdarg(method.Parameters[index]);
            }

            void ConvertLdarg(dnlib.DotNet.Parameter param)
            {
                var paramName = param.IsHiddenThisParameter ? "_this" : param.Name;
                stack.Push(param.Type, paramName);
            }

            void ConvertLdarga(dnlib.DotNet.Parameter param)
            {
                var paramName = param.IsHiddenThisParameter ? "_this" : param.Name;
                stack.Push(new ByRefSig(param.Type), $"::natsu::gc_ref_from_ref({paramName})");
            }

            void ConvertStarg(dnlib.DotNet.Parameter param)
            {
                var paramName = param.IsHiddenThisParameter ? "_this" : param.Name;

                var value = stack.Pop();
                writer.Ident(ident).WriteLine($"{paramName} = {CastExpression(param.Type, value)};");
            }

            void ConvertLdfld(IField field)
            {
                var target = stack.Pop();
                string expr = target.expression + (IsTargetValueType(target.type) ? "." : "->") + EscapeIdentifier(field.Name);
                stack.Push(field.FieldSig.Type, expr);
            }

            void ConvertLdflda(IField field)
            {
                var target = stack.Pop();
                string expr = target.expression + (IsTargetValueType(target.type) ? "." : "->") + EscapeIdentifier(field.Name);
                stack.Push(new ByRefSig(field.FieldSig.Type), $"::natsu::gc_ref_from_ref({expr})");
            }

            void ConvertStfld(IField field)
            {
                var value = stack.Pop();
                var target = stack.Pop();
                string expr = target.expression + (IsTargetValueType(target.type) ? "." : "->") + EscapeIdentifier(field.Name);
                var fieldType = field.FieldSig.Type;

                writer.Ident(ident).WriteLine($"{expr} = {CastExpression(fieldType, value)};");
            }

            string CastExpression(TypeSig dest, (TypeSig type, string expression) src)
            {
                if (src.type == null || dest != src.type)
                {
                    if (src.type == null || dest.IsValueType)
                        return $"static_cast<{EscapeTypeName(dest)}>({src.expression})";
                }

                return src.expression;
            }

            bool IsTargetValueType(TypeSig type)
            {
                return type.IsValueType;
            }

            string Access(TypeSig type)
            {
                return IsTargetValueType(type) ? "." : "->";
            }

            void ConvertLdsfld(IField field)
            {
                if (field.DeclaringType.ContainsGenericParameter)
                    throw new NotSupportedException();

                string expr = method.IsStaticConstructor && method.DeclaringType == field.DeclaringType
                    ? EscapeIdentifier(field.Name)
                    : "::natsu::static_holder<" + EscapeTypeName(field.DeclaringType, isBaseType: true, hasModuleName: true) + "_Static>::value." + EscapeIdentifier(field.Name);
                var fieldType = field.FieldSig.Type;

                stack.Push(fieldType, $"{expr}");
            }

            void ConvertStsfld(IField field)
            {
                if (field.DeclaringType.ContainsGenericParameter)
                    throw new NotSupportedException();

                var value = stack.Pop();
                string expr = method.IsStaticConstructor && method.DeclaringType == field.DeclaringType
                    ? EscapeIdentifier(field.Name)
                    : "::natsu::static_holder<" + EscapeTypeName(field.DeclaringType, isBaseType: true, hasModuleName: true) + "_Static>::value." + EscapeIdentifier(field.Name);
                var fieldType = field.FieldSig.Type;

                writer.Ident(ident).WriteLine($"{expr} = {value.expression};");
            }

            void ConvertLdloc_I(int index)
            {
                var local = method.Body.Variables[index];
                stack.Push(local.Type, $"_l{index}");
            }

            void ConvertLdloc(Local local)
            {
                stack.Push(local.Type, $"_l{local.Index}");
            }

            void ConvertLdloc_a(Local local)
            {
                stack.Push(new ByRefSig(local.Type), $"::natsu::gc_ref_from_ref(_l{local.Index})");
            }

            void ConvertStloc_I(int index)
            {
                ConvertStloc(method.Body.Variables[index]);
            }

            void ConvertStloc(Local local)
            {
                var value = stack.Pop();
                writer.Ident(ident).WriteLine($"_l{local.Index} = {CastExpression(local.Type, value)};");
            }

            void ConvertRet()
            {
                if (method.HasReturnType)
                {
                    var value = stack.Pop();
                    writer.Ident(ident).WriteLine($"return {CastExpression(method.ReturnType, value)};");
                }
                else
                {
                    writer.Ident(ident).WriteLine("return;");
                }
            }

            void ConvertLdc_I4(int value)
            {
                stack.Push(_corLibTypes.Int32, LiteralConstant(value));
            }

            void ConvertLdc_R8(double value)
            {
                stack.Push(_corLibTypes.Double, LiteralConstant(value));
            }

            void ConvertLdnull()
            {
                stack.Push(null, "::natsu::null");
            }

            void ConvertLdlen()
            {
                var target = stack.Pop();
                stack.Push(_corLibTypes.UInt32, $"{target.expression}->length()");
            }

            void ConvertNop()
            {
                writer.Ident(ident).WriteLine("::natsu::nop();");
            }

            void ConvertBr(Instruction instruction)
            {
                writer.Ident(ident).WriteLine($"goto {GetLabel(method, instruction, block)};");
            }

            void ConvertCeq()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.Int32, $"({v1.expression} == {v2.expression} ? 1 : 0)");
            }

            void ConvertBlt(Instruction instruction)
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                writer.Ident(ident).WriteLine($"if ({v1.expression} < {v2.expression})");
                writer.Ident(ident + 1).WriteLine($"goto {GetLabel(method, instruction, block)};");
                writer.Ident(ident).WriteLine("else");
                writer.Ident(ident + 1).WriteLine($"goto {GetFallthroughLabel(method, op, block)};");
            }

            void ConvertBne_Un(Instruction instruction)
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                writer.Ident(ident).WriteLine($"if (static_cast<uintptr_t>({v1.expression}) != static_cast<uintptr_t>({v2.expression}))");
                writer.Ident(ident + 1).WriteLine($"goto {GetLabel(method, instruction, block)};");
                writer.Ident(ident).WriteLine("else");
                writer.Ident(ident + 1).WriteLine($"goto {GetFallthroughLabel(method, op, block)};");
            }

            void ConvertBge_Un(Instruction instruction)
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                writer.Ident(ident).WriteLine($"if (static_cast<uintptr_t>({v1.expression}) > static_cast<uintptr_t>({v2.expression}))");
                writer.Ident(ident + 1).WriteLine($"goto {GetLabel(method, instruction, block)};");
                writer.Ident(ident).WriteLine("else");
                writer.Ident(ident + 1).WriteLine($"goto {GetFallthroughLabel(method, op, block)};");
            }

            void ConvertBrfalse(Instruction instruction)
            {
                var v1 = stack.Pop();
                writer.Ident(ident).WriteLine($"if (!{v1.expression})");
                writer.Ident(ident + 1).WriteLine($"goto {GetLabel(method, instruction, block)};");
                writer.Ident(ident).WriteLine("else");
                writer.Ident(ident + 1).WriteLine($"goto {GetFallthroughLabel(method, op, block)};");
            }

            void ConvertBrtrue(Instruction instruction)
            {
                var v1 = stack.Pop();
                writer.Ident(ident).WriteLine($"if ({v1.expression})");
                writer.Ident(ident + 1).WriteLine($"goto {GetLabel(method, instruction, block)};");
                writer.Ident(ident).WriteLine("else");
                writer.Ident(ident + 1).WriteLine($"goto {GetFallthroughLabel(method, op, block)};");
            }

            void ConvertCall(IMethodDefOrRef member)
            {
                var method = member.MethodSig;
                var para = new List<(TypeSig destType, (TypeSig type, string expression) src)>();
                var parasCount = method.Params.Count;
                for (int i = parasCount - 1; i >= 0; i--)
                    para.Add((method.Params[i], stack.Pop()));

                if (method.HasThis)
                    para.Add((member.DeclaringType.ToTypeSig(), stack.Pop()));

                para.Reverse();
                stack.Push(method.RetType, $"{EscapeTypeName(member.DeclaringType, isBaseType: true, hasModuleName: true)}::{EscapeMethodName(member)}({string.Join(", ", para.Select(x => CastExpression(x.destType, x.src)))})");
            }

            void ConvertCallvirt(IMethodDefOrRef member)
            {
                var method = member.MethodSig;
                var para = new List<(TypeSig destType, (TypeSig type, string expression) src)>();
                var parasCount = method.Params.Count;
                for (int i = parasCount - 1; i >= 0; i--)
                    para.Add((method.Params[i], stack.Pop()));

                if (method.HasThis)
                    para.Add((member.DeclaringType.ToTypeSig(), stack.Pop()));

                para.Reverse();
                stack.Push(method.RetType, $"{para[0].src.expression}->header_.vtable_as<{EscapeTypeName(member.DeclaringType, isBaseType: true, hasModuleName: true)}::VTable>()->{EscapeMethodName(member)}({string.Join(", ", para.Select(x => CastExpression(x.destType, x.src)))})");
            }

            void ConvertNewobj(IMethodDefOrRef member)
            {
                var method = member.MethodSig;
                var para = new List<string>();
                var parasCount = method.Params.Count;
                for (int i = parasCount - 1; i >= 0; i--)
                    para.Add(stack.Pop().expression);

                para.Reverse();

                var t = member.DeclaringType;
                var expr = EscapeTypeName(t, true, true);
                var isValueType = member.DeclaringType.IsValueType ? "true" : "false";
                stack.Push(member.DeclaringType.ToTypeSig(), $"::natsu::make_object<{expr}, {isValueType}>({string.Join(", ", para)})");
            }

            void ConvertNewarr(ITypeDefOrRef type)
            {
                var len = stack.Pop();
                stack.Push(new SZArraySig(type.ToTypeSig()), $"::natsu::gc_new_array<{EscapeTypeName(type.ToTypeSig())}>({len.expression})");
            }

            void ConvertLdstr(string str)
            {
                stack.Push(_corLibTypes.String, $"::natsu::load_string(uR\"NS({str})NS\")");
            }

            void ConvertConv_I4()
            {
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.Int32, $"static_cast<int32_t>({PointerToU(v1)})");
            }

            void ConvertConv_U4()
            {
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.UInt32, $"static_cast<uint32_t>({PointerToU(v1)})");
            }

            void ConvertConv_I8()
            {
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.Int64, $"static_cast<int64_t>({PointerToU(v1)})");
            }

            void ConvertConv_I()
            {
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.IntPtr, $"static_cast<intptr_t>({PointerToU(v1)})");
            }

            void ConvertConv_U()
            {
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.UIntPtr, $"static_cast<uintptr_t>({PointerToU(v1)})");
            }

            void ConvertConv_U1()
            {
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.Byte, $"static_cast<uint8_t>({PointerToU(v1)})");
            }

            void ConvertConv_U8()
            {
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.UInt64, $"static_cast<uint64_t>({PointerToU(v1)})");
            }

            string PointerToU((TypeSig type, string expression) src)
            {
                if (src.type != null && (src.type.IsPointer || src.type.IsByRef))
                    return $"static_cast<uintptr_t>({src.expression})";
                return src.expression;
            }

            void ConvertDup()
            {
                var value = stack.Peek();
                stack.Push(value.type, value.expression);
            }

            void ConvertStelem_I4()
            {
                var value = stack.Pop();
                var index = stack.Pop();
                var target = stack.Pop();
                writer.Ident(ident).WriteLine($"{target.expression}->set({index.expression}, {value.expression});");
            }

            void ConvertLdelem_I4()
            {
                var index = stack.Pop();
                var target = stack.Pop();
                stack.Push(((SZArraySig)target.type).Next, $"{target.expression}->get({index.expression})");
            }

            void ConvertIsinst(ITypeDefOrRef type)
            {
                var target = stack.Pop();
                stack.Push(new SZArraySig(type.ToTypeSig()), $"{target.expression}.as<{EscapeTypeName(type, isBaseType: true, hasModuleName: true)}>()");
            }

            void ConvertCgt_Un()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.Int32, $"(static_cast<uintptr_t>({v1.expression}) > static_cast<uintptr_t>({v2.expression}) ? 1 : 0)");
            }

            void ConvertCgt()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.Int32, $"{v1.expression} > {v2.expression}");
            }

            void ConvertClt()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(_corLibTypes.Int32, $"{v1.expression} < {v2.expression}");
            }

            void ConvertUnbox_Any(ITypeDefOrRef type)
            {
                var target = stack.Pop();
                stack.Push(new ByRefSig(type.ToTypeSig()), $"{target.expression}.unbox<{EscapeTypeName(type, isBaseType: true, hasModuleName: true)}>()");
            }

            void ConvertAdd()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(v1.type, $"{v1.expression} + {v2.expression}");
            }

            void ConvertSub()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(v1.type, $"{v1.expression} - {v2.expression}");
            }

            void ConvertLdind_U1()
            {
                var address = stack.Pop();
                stack.Push(_corLibTypes.Byte, $"*reinterpret_cast<uint8_t *>({PointerToU(address)});");
            }

            void ConvertStind_I1()
            {
                var value = stack.Pop();
                var address = stack.Pop();
                writer.Ident(ident).WriteLine($"*{address.expression} = {value.expression};");
            }

            void ConvertLdelema(ITypeDefOrRef type)
            {
                var index = stack.Pop();
                var target = stack.Pop();
                stack.Push(new ByRefSig(type.ToTypeSig()), $"{target.expression}->ref_at({index.expression})");
            }

            void ConvertShr()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(v1.type, $"{v1.expression} >> {v2.expression}");
            }

            void ConvertShr_Un()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(v1.type, $"{v1.expression} >> {v2.expression}");
            }

            void ConvertXor()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(v1.type, $"{v1.expression} ^ {v2.expression}");
            }

            void ConvertAnd()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(v1.type, $"{v1.expression} & {v2.expression}");
            }

            void ConvertOr()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(v1.type, $"{v1.expression} | {v2.expression}");
            }

            void ConvertMul()
            {
                var v2 = stack.Pop();
                var v1 = stack.Pop();
                stack.Push(v1.type, $"{v1.expression} * {v2.expression}");
            }

            void ConvertThrow()
            {
                var v1 = stack.Pop();
                writer.Ident(ident).WriteLine($"throw ::natsu::make_exception({v1.expression});");
            }

            switch (op.OpCode.Code)
            {
                case Code.Ldarg_0:
                    ConvertLdarg_I(0);
                    break;
                case Code.Ldarg_1:
                    ConvertLdarg_I(1);
                    break;
                case Code.Ldarg_2:
                    ConvertLdarg_I(2);
                    break;
                case Code.Ldarg_3:
                    ConvertLdarg_I(3);
                    break;
                case Code.Ldarg:
                    ConvertLdarg_I((int)op.Operand);
                    break;
                case Code.Ldarg_S:
                    ConvertLdarg((dnlib.DotNet.Parameter)op.Operand);
                    break;
                case Code.Ldarga_S:
                    ConvertLdarga((dnlib.DotNet.Parameter)op.Operand);
                    break;
                case Code.Starg_S:
                    ConvertStarg((dnlib.DotNet.Parameter)op.Operand);
                    break;
                case Code.Ldfld:
                    ConvertLdfld((IField)op.Operand);
                    break;
                case Code.Ldflda:
                    ConvertLdflda((IField)op.Operand);
                    break;
                case Code.Stfld:
                    ConvertStfld((IField)op.Operand);
                    break;
                case Code.Ldsfld:
                    ConvertLdsfld((IField)op.Operand);
                    break;
                case Code.Stsfld:
                    ConvertStsfld((IField)op.Operand);
                    break;
                case Code.Ret:
                    ConvertRet();
                    break;
                case Code.Ldc_I4_0:
                    ConvertLdc_I4(0);
                    break;
                case Code.Ldc_I4_1:
                    ConvertLdc_I4(1);
                    break;
                case Code.Ldc_I4_2:
                    ConvertLdc_I4(2);
                    break;
                case Code.Ldc_I4_3:
                    ConvertLdc_I4(3);
                    break;
                case Code.Ldc_I4_4:
                    ConvertLdc_I4(4);
                    break;
                case Code.Ldc_I4_5:
                    ConvertLdc_I4(5);
                    break;
                case Code.Ldc_I4_6:
                    ConvertLdc_I4(6);
                    break;
                case Code.Ldc_I4_7:
                    ConvertLdc_I4(7);
                    break;
                case Code.Ldc_I4_8:
                    ConvertLdc_I4(8);
                    break;
                case Code.Ldc_I4:
                    ConvertLdc_I4((int)op.Operand);
                    break;
                case Code.Ldc_I4_S:
                    ConvertLdc_I4((sbyte)op.Operand);
                    break;
                case Code.Ldc_R8:
                    ConvertLdc_R8((double)op.Operand);
                    break;
                case Code.Ldlen:
                    ConvertLdlen();
                    break;
                case Code.Call:
                    ConvertCall((IMethodDefOrRef)op.Operand);
                    break;
                case Code.Callvirt:
                    ConvertCallvirt((IMethodDefOrRef)op.Operand);
                    break;
                case Code.Ldloc_0:
                    ConvertLdloc_I(0);
                    break;
                case Code.Ldloc_1:
                    ConvertLdloc_I(1);
                    break;
                case Code.Ldloc_2:
                    ConvertLdloc_I(2);
                    break;
                case Code.Ldloc_3:
                    ConvertLdloc_I(3);
                    break;
                case Code.Ldloc_S:
                    ConvertLdloc((Local)op.Operand);
                    break;
                case Code.Ldloca_S:
                    ConvertLdloc_a((Local)op.Operand);
                    break;
                case Code.Stloc_0:
                    ConvertStloc_I(0);
                    break;
                case Code.Stloc_1:
                    ConvertStloc_I(1);
                    break;
                case Code.Stloc_2:
                    ConvertStloc_I(2);
                    break;
                case Code.Stloc_3:
                    ConvertStloc_I(3);
                    break;
                case Code.Stloc_S:
                    ConvertStloc((Local)op.Operand);
                    break;
                case Code.Nop:
                    ConvertNop();
                    break;
                case Code.Br_S:
                    ConvertBr((Instruction)op.Operand);
                    break;
                case Code.Blt_S:
                    ConvertBlt((Instruction)op.Operand);
                    break;
                case Code.Bne_Un_S:
                    ConvertBne_Un((Instruction)op.Operand);
                    break;
                case Code.Bge_Un_S:
                    ConvertBge_Un((Instruction)op.Operand);
                    break;
                case Code.Ceq:
                    ConvertCeq();
                    break;
                case Code.Brfalse_S:
                    ConvertBrfalse((Instruction)op.Operand);
                    break;
                case Code.Brtrue_S:
                    ConvertBrtrue((Instruction)op.Operand);
                    break;
                case Code.Ldnull:
                    ConvertLdnull();
                    break;
                case Code.Ldstr:
                    ConvertLdstr((string)op.Operand);
                    break;
                case Code.Conv_I4:
                case Code.Conv_Ovf_I4:
                    ConvertConv_I4();
                    break;
                case Code.Conv_U4:
                case Code.Conv_Ovf_U4:
                case Code.Conv_Ovf_U4_Un:
                    ConvertConv_U4();
                    break;
                case Code.Conv_I8:
                    ConvertConv_I8();
                    break;
                case Code.Conv_I:
                    ConvertConv_I();
                    break;
                case Code.Conv_U:
                    ConvertConv_U();
                    break;
                case Code.Conv_U1:
                    ConvertConv_U1();
                    break;
                case Code.Conv_U8:
                    ConvertConv_U8();
                    break;
                case Code.Newobj:
                    ConvertNewobj((IMethodDefOrRef)op.Operand);
                    break;
                case Code.Newarr:
                    ConvertNewarr((ITypeDefOrRef)op.Operand);
                    break;
                case Code.Dup:
                    ConvertDup();
                    break;
                case Code.Ldelem_I4:
                    ConvertLdelem_I4();
                    break;
                case Code.Stelem_I4:
                    ConvertStelem_I4();
                    break;
                case Code.Isinst:
                    ConvertIsinst((ITypeDefOrRef)op.Operand);
                    break;
                case Code.Cgt_Un:
                    ConvertCgt_Un();
                    break;
                case Code.Cgt:
                    ConvertCgt();
                    break;
                case Code.Clt:
                    ConvertClt();
                    break;
                case Code.Unbox_Any:
                    ConvertUnbox_Any((ITypeDefOrRef)op.Operand);
                    break;
                case Code.Unbox:
                    ConvertUnbox_Any((ITypeDefOrRef)op.Operand);
                    break;
                case Code.Add:
                    ConvertAdd();
                    break;
                case Code.Sub:
                    ConvertSub();
                    break;
                case Code.Ldind_U1:
                    ConvertLdind_U1();
                    break;
                case Code.Stind_I1:
                    ConvertStind_I1();
                    break;
                case Code.Ldelema:
                    ConvertLdelema((ITypeDefOrRef)op.Operand);
                    break;
                case Code.Shr:
                    ConvertShr();
                    break;
                case Code.Shr_Un:
                    ConvertShr_Un();
                    break;
                case Code.Xor:
                    ConvertXor();
                    break;
                case Code.And:
                    ConvertAnd();
                    break;
                case Code.Or:
                    ConvertOr();
                    break;
                case Code.Mul:
                    ConvertMul();
                    break;
                case Code.Throw:
                    ConvertThrow();
                    break;
                case Code.Volatile:
                    break;
                case Code.Constrained:
                    break;
                default:
                    throw new NotSupportedException(op.ToString());
            }

            writer.Flush();
        }

        class EvaluationStack
        {
            private readonly Stack<(TypeSig type, string expression)> _stackValues = new Stack<(TypeSig type, string expression)>();
            private int _paramIndex = 0;
            private StreamWriter _writer;
            public int Ident { get; }

            public EvaluationStack(StreamWriter writer, int ident)
            {
                _writer = writer;
                Ident = ident;
            }

            public void Push(TypeSig type, string expression)
            {
                if (type != null && type.ElementType == ElementType.Void)
                {
                    _writer.Ident(Ident).WriteLine($"{expression};");
                }
                else
                {
                    var id = $"_v{_paramIndex++}";
                    _writer.Ident(Ident).WriteLine($"auto&& {id} = {expression};");
                    _stackValues.Push((type, id));
                }
            }

            public (TypeSig type, string expression) Pop()
            {
                return _stackValues.Pop();
            }

            public (TypeSig type, string expression) Peek()
            {
                return _stackValues.Peek();
            }

            public EvaluationStack Clone(int identInc = 0)
            {
                var stack = new EvaluationStack(_writer, Ident + identInc);
                foreach (var value in _stackValues)
                    stack._stackValues.Push(value);
                stack._paramIndex = _paramIndex;
                return stack;
            }
        }

        private static string GetEnumUnderlyingTypeName(ElementType type)
        {
            switch (type)
            {
                case ElementType.I1:
                    return "int8_t";
                case ElementType.U1:
                    return "uint8_t";
                case ElementType.I2:
                    return "int16_t";
                case ElementType.U2:
                    return "uint16_t";
                case ElementType.I4:
                    return "int32_t";
                case ElementType.U4:
                    return "uint32_t";
                case ElementType.I8:
                    return "int64_t";
                case ElementType.U8:
                    return "uint64_t";
                default:
                    throw new ArgumentException("Invalid enum underlying type");
            }
        }

        private static string GetConstantTypeName(ElementType type)
        {
            switch (type)
            {
                case ElementType.Boolean:
                    return "bool";
                case ElementType.Char:
                    return "char16_t";
                case ElementType.I1:
                    return "int8_t";
                case ElementType.U1:
                    return "uint8_t";
                case ElementType.I2:
                    return "int16_t";
                case ElementType.U2:
                    return "uint16_t";
                case ElementType.I4:
                    return "int32_t";
                case ElementType.U4:
                    return "uint32_t";
                case ElementType.I8:
                    return "int64_t";
                case ElementType.U8:
                    return "uint64_t";
                case ElementType.R4:
                    return "float";
                case ElementType.R8:
                    return "double";
                case ElementType.String:
                    return "::natsu::gc_obj_ref<::System_Private_CorLib::System::String>";
                case ElementType.I:
                    return "intptr_t";
                case ElementType.U:
                    return "uintptr_t";
                default:
                    throw new ArgumentException("Invalid constant type");
            }
        }

        private static string EscapeModuleName(ModuleDef module)
        {
            return EscapeModuleName(module.Assembly.Name);
        }

        private static string EscapeModuleName(IAssembly assembly)
        {
            return EscapeModuleName(assembly.Name);
        }

        private static string EscapeModuleName(string name)
        {
            return name.Replace('.', '_');
        }

        private static string EscapeMethodName(IMethodDefOrRef method)
        {
            if (method.MethodSig.HasThis)
                return EscapeIdentifier(method.Name);
            else if (method.Name.EndsWith("op_Explicit"))
                return "_s_" + EscapeIdentifier(method.Name) + "_" + EscapeIdentifier(method.MethodSig.RetType.FullName);
            else if (method.Name == ".cctor")
                return EscapeTypeName(method.DeclaringType.Name) + "_Static";
            else
                return "_s_" + EscapeIdentifier(method.Name);
        }

        private static string EscapeNamespaceName(string ns)
        {
            return ns;
        }

        class TypeDesc
        {
            public TypeDef TypeDef { get; }

            public UTF8String Name { get; set; }

            public string QualifiedName { get; set; }

            public Dictionary<UTF8String, TypeDesc> Nested { get; } = new Dictionary<UTF8String, TypeDesc>();

            public HashSet<TypeDesc> UsedTypes { get; } = new HashSet<TypeDesc>();

            public HashSet<TypeDesc> UsedByTypes { get; } = new HashSet<TypeDesc>();

            public TypeDesc(TypeDef typeDef)
            {
                TypeDef = typeDef;
                Name = EscapeName(typeDef.Name);
                QualifiedName = Name;
            }

            public override string ToString()
            {
                return QualifiedName;
            }

            public static string EscapeName(string name)
            {
                return EscapeIdentifier(name);
            }
        }

        private static string EscapeIdentifier(string name)
        {
            if (string.IsNullOrEmpty(name))
                throw new ArgumentException("Invalid identifier");

            return name.Replace('<', '_').Replace('>', '_').Replace('`', '_').Replace('.', '_').Replace('*', '_');
        }
    }

    internal static class Extensions
    {
        public static StreamWriter Ident(this StreamWriter writer, int ident)
        {
            for (int i = 0; i < ident; i++)
                writer.Write("    ");
            return writer;
        }
    }
}
